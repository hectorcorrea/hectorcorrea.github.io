<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="HectorCorrea.com">
    <meta name="author" content="hector@hectorcorrea.com">

    <title>HectorCorrea.com</title>

    <link rel="shortcut icon" href="/public/favicon.ico" />
    <link rel="apple-touch-icon" href="/public/favicon.png"/>

    <!-- Styles from https://newcss.net/ -->
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.css">

    <link rel="me" href="https://mastodon.social/@hectorjcorrea" />
    <link rel="canonical" href="https://hectorcorrea.com" />

    <!-- Lunr.js for searching, Mark.js for highlighting search results -->
    <script src="/public/lunr.min.js"></script>
    <script src="/public/mark.min.js"></script>

    <style>
      img {
        padding: 5px;
        box-shadow: 3px 3px 8px #222;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      footer {
        background: var(--nc-bg-2);
        border-bottom: 1px solid var(--nc-bg-3);
        padding: 2rem 1.5rem;

        margin: -2rem calc(0px - (50vw - 50%)) 2rem;

        padding-left: calc(50vw - 50%);
        padding-right: calc(50vw - 50%);

        margin-top: -0px;
        margin-bottom: 0px;
        padding-top: 6px;
        padding-bottom: 6px;
        color: gray;
        font-size: x-small;
      }

      .header-link {
        /* Main body text, see new.css */
        color: var(--nc-tx-2);
        text-decoration: none;
      }

      .nav-link-selected {
        font-weight: bold;
      }

      .search-options {
        float: right;
      }

      .highlight-icon-on > a {
        background: var(--nc-ac-1);
      }

      .highlight-icon-off > a {
        background: var(--nc-bg-2);
      }

      .invisible {
        display: none;
      }

      .socialLogo {
        padding: 0px;
        box-shadow: none;
        margin-right: 0px;
        margin-bottom: 0px;
        width: 16px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1><a class="header-link" href="/">Hector Correa</a></h1>
      <nav>
        <a id="about-menu" href="/about">About</a>
        | <a id="presentations-menu" href="/presentations">Presentations</a>
        | <a id="blog-menu" href="/blog">Blog</a>
        <span class="search-options">
          <span>
            <a href="/search" title="Search">
              <!--Magnifying glass source: https://icons.getbootstrap.com/icons/search/ -->
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
                <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
              </svg></a>
          </span>
          <span id="highlight-menu" class="invisible">
            <a href="#" title="Toggle highlight">
              <!-- Highlighter source: https://icons.getbootstrap.com/icons/highlighter/ -->
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-highlighter" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M11.096.644a2 2 0 0 1 2.791.036l1.433 1.433a2 2 0 0 1 .035 2.791l-.413.435-8.07 8.995a.5.5 0 0 1-.372.166h-3a.5.5 0 0 1-.234-.058l-.412.412A.5.5 0 0 1 2.5 15h-2a.5.5 0 0 1-.354-.854l1.412-1.412A.5.5 0 0 1 1.5 12.5v-3a.5.5 0 0 1 .166-.372l8.995-8.07zm-.115 1.47L2.727 9.52l3.753 3.753 7.406-8.254zm3.585 2.17.064-.068a1 1 0 0 0-.017-1.396L13.18 1.387a1 1 0 0 0-1.396-.018l-.068.065zM5.293 13.5 2.5 10.707v1.586L3.707 13.5z"/>
              </svg>
            </a>
          </span>
        </span>
      </nav>
    </header>

    <div id="page-content">
      <h1>Learning JavaScript Data Structures and Algorithms</h1>
<p><img src="https://hectorcorrea.com/images/js_book_thumb.jpg" style="float:left;" /> The folks at Packt Publishing asked me to review one of their newest books <a href="https://www.packtpub.com/application-development/learning-javascript-data-structures-and-algorithms">Learning JavaScript Data Structures and Algorithms</a> by Loiane Groner.<sup>[1]</sup></p>

<p>As a fan of data structures and algorithms I am glad to see a book on the subject targeted at JavaScript developers. The publication of this book is rather timely given the tremendous growth in popularity that JavaScript has experienced over the years, not only as <i>the</i> language for front-end web development, but also recently as a viable alternative for backend development via Node.js. Although there are a lot of books on data structures and algorithms, most of them are targeted to Java/C developers, and there is very little on the subject for JavaScript developers. As Groner indicates<sup>[2]</sup> "who said data structures and algorithms were only made for languages such as C and Java" [p. 37]</p>

<p>In this book Groner describes some of the basic data structures and algorithms that most books in this category typically cover including Stacks, Queues, Lists, Trees, Graphs, Sorting and Searching and provides clear and simple implementations for them in JavaScript. Many developers would benefit from reading this book, but particularly those who started their software development career with JavaScript (or other scripting language) and haven't taken traditional computer science degree courses where data structures and algorithms are typically taught.</p>

<p>Although there are already other good beginner-level books on data structures and algorithms (see <sup>[3]</sup> and <sup>[4]</sup> for example) they tend to be targeted at people studying a computer science degree with the help of a professor in a traditional classroom setting. Groner's book on the other hand is a gentler introduction to the subject and I would assume a better fit for those learning data structures and algorithms for the first time on their own. Given that I have a computer science degree and have been writing code for over two decades I might not be the best judge of this, but I found Groner's book much easier to follow than other introductory books<sup>[5]</sup>.</p>

<p>Groner does a great job of describing the data structures, the mechanics of the algorithms, and provides clear and concise JavaScript implementations. Each chapter begins with a short introduction to the terminology needed to understand the data structures and algorithms presented. This is very important as the complexity of the material increases on each new chapter and yet she manages to keep both, the explanations and code implementation, simple and accurate.</p>

<p>Groner wrote the examples so that they can be run on any modern browser with little or no setup required from the reader. She also provides instructions on how to setup a simple web server to have a better experience navigating through the different examples on each chapter. I think this painless setup will appeal to a lot of readers that tend to shy away from heavy server-side development. The samples can also be easily be adapted to run server side via Node.js for those inclined to do server-side development with JavaScript, though.</p>

<p>All of the code examples presented in the book are available online at this GitHub repo: <a href="https://github.com/loiane/javascript-datastructures-algorithms">https://github.com/loiane/javascript-datastructures-algorithms</a>.</p>


<h2>The basics</h2>
<p><img src="https://hectorcorrea.com/images/js_queue_thumb.jpg" style="float:left;" /> The book starts with an introduction to JavaScript and a tour of the features of Arrays in JavaScript. I appreciate that Groner spends a full chapter on Arrays given that in JavaScript they come with a lot of built-in functionality typically not found in other languages (e.g. slice, map, reduce, filter, shift); this chapter also explains some of the nuances using arrays in JavaScript (e.g. sort is by default lexicographical).</p>

<p>The first two data structures presented in the book are <b>Stacks</b> and <b>Queues</b> and they are implemented via arrays. Using arrays for these data structures allowed Groner to keep the examples concise and keep the focus on the algorithms themselves (e.g. FIFO vs LIFO) and implement some variations (like Priority Queue and Circular Queue) relatively easily.</p>

<p>I appreciate how clear and concise most of the code examples throughout the book are. For example, in barely 30 lines of code<sup>[6][7]</sup> Groner shows how to implement a Queue in JavaScript. Below is a snippet of this code:</p>

<pre class="code">
// Queue implementation (partial)
function Queue() {
  var items = [];

  this.enqueue = function(element){
    items.push(element);
  };

  this.dequeue = function(){
    return items.shift();
  };

  this.print = function(){
    console.log(items.toString());
  };
}

// Using the queue
var q = new Queue();
console.log(queue.isEmpty()); 
q.enqueue("Hello");
q.enqueue("World");
q.print();
q.dequeue();
</pre>

<p>After presenting Stacks and Queues Groner moves to more complex data structures like <b>Linked Lists</b>, <b>Sets</b>, <b>Dictionaries</b> and, <b>Hashes</b>. I liked how smoothly Groner reused data structures implemented in previous chapters. For example, on chapter 7 when implementing a technique to handle collisions in a HashTable she uses the LinkedList implementation that she presented on Chapter 5 as shown in this code snippet [p. 237].</p>

<pre class="code">
// original implementation
this.put = function(key, value) {
  var position = loseloseHashCode(key);
  table[position] = value;
};

// improved version
this.put = function(key, value) {
  var position = loseloseHashCode(key);
  if (table[position] == undefined) {
    table[position] = new LinkedList();      
  }
  table[position].append(new ValuePair(key, value)); 
};
</pre>

<p>I enjoyed that Groner consistently covers the basic implementations of most algorithms and in some cases even discusses interesting variations. For example, in addition to the basic Linked List she touches on Double Linked lists and Circular Linked Lists. Likewise, the chapter on Dictionaries and Hashes not only describes the basis of them but also how to handle collisions and how to implement a Hash Table.</p>


<h2>Trees and Graphs</h2>
<p><img style="float:left" src="https://hectorcorrea.com/images/js_tree_thumb.jpg" />The last two data structures that Groner explains in her book are <b>Trees</b> and <b>Graphs</b>. The code implementations for these chapters are of course more complex than previous ones but Groner manages to keep the code clear and simple. She uses recursive implementations for most of the operations of these chapters to keep the code concise. Although recursive implementations don't always work with large loads, given that the goal of the book is to introduce the concepts to beginners rather than stress test the algorithms, the use of recursive implementations makes sense<sup>[8]</sup>.</p>

<p>I was glad to see that Groner explains and implements all of the basic operations for Trees, <i>including the complex ones</i> like removing a node from a tree, to give a comprehensive overview of the algorithms. She also explains the basic traversal operations for binary trees (in-order, pre-order, post-order) and provides guidance on other kinds of trees that readers should explore should they want to learn more about this subject. The same is true for Graphs. Groner does a nice job explaining some of different strategies that can be use to implement them (e.g. via an adjacency matrix, an adjacency list, or an incident matrix) and when each implementation is best suited.</p>

<p>As mentioned before, Groner takes advantage of data structures presented and implemented in previous chapters to implement more complex ones. Below is a fragment of the code to implement a Graph and the <i>add vertex</i> and <i>add edge</i> operations. Notice how she takes advantage of the Dictionary to store the adjacency list. The full implementation is 170+ lines of code and it's available <a href="https://github.com/loiane/javascript-datastructures-algorithms/blob/master/chapter09/01-Graph.js">on the GitHub repo</a>.</p>

<pre class="code">
function Graph() {
  var vertices = []; 
  var adjList = new Dictionary();

  this.addVertex = function(v){
    vertices.push(v);
    adjList.set(v, []); //initialize adjacency list with array as well;
  };

  this.addEdge = function(v, w){
    adjList.get(v).push(w);
    adjList.get(w).push(v);
  };
}
</pre>

<p>Groner also explains two common Graph traversal algorithms: <b>Bread-First Search</b> and <b>Depth-First Search</b> and their implementations in JavaScript. These very important topics and not easy to explain but she manages to describe them in good detail along with basic code implementations that you can run to see the algorithm in action.</p>


<h2>Searching and sorting</h2>
<p>The last chapter of the book is dedicated to searching and sorting. Groner introduces the reader to some basic sorting algorithms (i.e. bubble sort, merge sort, insertion sort, quick sort) and their implementation in JavaScript. I found it odd that there was no explanation on how these algorithms have different execution times depending on how the data is sorted at the beginning, though.</p>

<p>In this chapter Groner also presents the binary search algorithm. Although the description of the algorithm and its implementation were accurate, I felt like this section could have been better connected to the binary search tree explored in the previous chapter. There is a note on this chapter linking the two but, given that this book is for beginners, I would have liked to see a bit more explanation on their different usages (e.g. sorting data as it is inserted versus sorting after the fact.)</p>


<h2>Bonus Chapter</h2>
<p>There is also a free online extra chapter titled <a href="https://www.packtpub.com/sites/default/files/downloads/4874OS_Chapter11_More_About_Algorithms.pdf">More About Algorithms</a> in which Groner covers in some detail concepts that are mentioned throughout the book like recursion, Fibonacci, and big-O notation. This chapter is mentioned on the eBook [p. 26], but it is not well advertised on the PacktPub's web site. It's worth checking out if those concepts are new to you.</p>


<h2>Criticism</h2>
<p>Although the content of the book is excellent and the code implementations for the algorithms seem accurate, I felt that this book could have used a bit more editing before going to press. Throughout the book I ran into some sentences that seem to have been dropped in the middle without much context or connection to the rest of the book. I was a bit surprised by this lack of editing given that there are several reviewers listed on this book so I suspect that they focused on the accuracy of the technical implementations (as they should) rather than making the book feel more polished.</p>

<p>Another area that I would have liked to see improved is the visualization of the algorithms. The code provided outputs the results to the debug console. I think it would have been nicer if the output was to a web page, yet I also realize outputting to the debug console via <code>console.log()</code> keeps the samples more concise. Likewise, the code as-provided needs to be tweaked in order to run in Node.js. It would have been nice if the code were provided in a way that could be run unchanged on both the browser and the server.</p>

<p>Overall these are minor criticisms on the book. As I indicated above, the content and the explanations are excellent for an introductory level book as are the JavaScript implementations provided.</p>


<h2>Summary</h2>
<p>As a computer science student in college I found data structures and algorithms a fascinating topic. Many years later, as a practitioner, I still find them fascinating and intellectually challenging<sup>[9]</sup>. Although most of us will never be asked to implement a particular algorithm like the ones described in this book, I have always seen them as a great way to learn different programming techniques and keep our development skills sharp.</p>

<p>I think Groner's book is a great introductory book to the subject and I am glad to see authors focusing on JavaScript developers that might have never been exposed to this topic. Even those that have been exposed to these concepts before (and found them a bit dry) will find Groner's book good way to revisit these concepts and have fun implementing them.</p>


<h3>References</h3>
<p>[1] Disclaimer: Packt Publishing gave me access to a free copy of the eBook for me to write this review. I did not receive any other compensation for it.</p>
<p>[2] Given that I used an eBook to write this review, please note that page numbers might be different in other formats. To facilitate their location I also indicate the chapter in which they appear.</p>
<p>[3] <a href="http://www.amazon.com/gp/product/0262033844">Introduction to Algorithms</a> by Thomas H. Cormen et. al.</p>
<p>[4] <a href="http://www.amazon.com/Algorithms-4th-Edition-Robert-Sedgewick/dp/032157351X">Algorithms</a> by Robert Sedgewick and Kevin Wayne</p>
<p>[5] O'Reilly <a href="http://www.amazon.com/Structures-Algorithms-JavaScript-Michael-McMillan/dp/1449364934">recently published another book</a> with almost the exact same title and table of contents but I have not read it so I cannot compare the two.</p>
<p>[6] Full Queue implementation at <a href="https://github.com/loiane/javascript-datastructures-algorithms/blob/master/chapter04/01-Queue.js">https://github.com/loiane/javascript-datastructures-algorithms/blob/master/chapter04/01-Queue.js</a></p>
<p>[7] Full example at <a href="https://github.com/loiane/javascript-datastructures-algorithms/blob/master/chapter04/02-UsingQueues.js">https://github.com/loiane/javascript-datastructures-algorithms/blob/master/chapter04/02-UsingQueues.js</a></p>
<p>[8] In fact, on page 4 of <a href="https://www.packtpub.com/sites/default/files/downloads/4874OS_Chapter11_More_About_Algorithms.pdf">the bonus chapter 11</a> she explicitly says that although recursive implementations might be slower than non-recursive ones they are easier to understand and require less code.</p>
<p>[9] Shameless plug. Over the years I've posted on my blog examples on how to implement and draw Binary Search Trees on <a href="https://hectorcorrea.com/blog/drawing-a-binary-tree-in-ruby/13">Ruby</a> and <a href="https://hectorcorrea.com/blog/drawing-a-binary-tree-in-coffeescript/3">CoffeeScript</a>.</p>


    </div>

    <div id="search-section" class="invisible">
      <div id="search-params" class="">
        <input id="search-terms" size="50" />
        <button id="search-button">Go</button>
      </div>
      <div id="search-results">
      </div>
    </div>

    <footer>
      <a href="/tooling">Tooling</a> |
      License <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
    </footer>

    <script type="text/javascript">
      // Redirect legacy blog URLs
      if (window.location.hash.startsWith("#/blog")) {
        window.location = window.location.toString().replace("#/blog/","blog/");
      }

      // Hande this redirect via JavaScript because GitHub pages does not let me
      // handle this via an HTML redirect due to the ".aspx" extension
      if (window.location.pathname === "/blog/The-Mythical-Man-Month.aspx") {
        window.location = "https://hectorcorrea.com/blog/2007-06-28/the-mythical-man-month";
      }

      // Mark as selected the current menu option
      var selectMenu = function() {
        var activeOption = null;
        var url = window.location.pathname;
        if (url.startsWith("/blog/")) {
          activeOption = document.getElementById("blog-menu");
        } else if(url == "/about") {
          activeOption = document.getElementById("about-menu");
        } else if(url == "/presentations") {
          activeOption = document.getElementById("presentations-menu");
        }

        if (activeOption != null) {
          activeOption.classList.add("nav-link-selected");
        }
      }


      // Show the highlight menu if there is a hl query string parameter.
      // Notice that we don't automatically highlight search terms because that's annoying on the display
      // when there are too many hits.
      var showHighlightMenu = function() {
        const queryString = window.location.search
        const urlParams = new URLSearchParams(queryString);
        if (urlParams.has("hl")) {
          var hlMenu = document.getElementById("highlight-menu");
          hlMenu.classList.remove("invisible");
        }
      }

      // Highlight search terms indicated in the URL via the
      // hl query string parameter
      var highlightSearchTerms = function() {
        const queryString = window.location.search
        const urlParams = new URLSearchParams(queryString);
        if (urlParams.has("hl")) {
          var context = document.querySelector("#page-content");
          var instance = new Mark(context);
          instance.mark(urlParams.get("hl"));
          var hlMenu = document.getElementById("highlight-menu");
          hlMenu.classList.remove("invisible");
          hlMenu.classList.add("highlight-icon-on");
          hlMenu.classList.remove("highlight-icon-off");
        }
      }

      // Unhighlight the search terms
      var unhighlightSearchTerms = function() {
        var context = document.querySelector("#page-content");
        var instance = new Mark(context);
        instance.unmark();
        var hlMenu = document.getElementById("highlight-menu");
        hlMenu.classList.remove("highlight-icon-on");
        hlMenu.classList.add("highlight-icon-off");
      }

      // Wire the button to toggle the highlight
      document.getElementById("highlight-menu").addEventListener("click", (event) => {
        var hlMenu = document.getElementById("highlight-menu");
        if (hlMenu.classList.contains("highlight-icon-on")) {
          unhighlightSearchTerms();
        } else {
          highlightSearchTerms();
        }
      });

      selectMenu();
      showHighlightMenu();
    </script>

    <script>
      if (window.location.pathname.startsWith("/search")) {
        // Only load the search index when we are on the search page
        // since it's kind of heavy, ~200KB.
        // Source https://stackoverflow.com/a/52478867/446681
        //
        // IMPORTANT: The call to document.write() will insert the
        // dynamic <script src=/searchIndex.js> block immediately
        // after this <script> block and therefore the code to
        // reference it MUST be on a separate <script> block.
        console.log("Loaded search index");
        document.write('<script src="/searchIndex.js"><\/script>');
      }
    </script>

    <script>
      // This <script> block has access to the searchDocuments
      // variable defined in searchIndex.js (see above)
      if (window.location.pathname.startsWith("/search")) {
        // Define the Lunr index
        var lunrIndex = lunr(function () {
          this.ref('id')
          this.field('name')
          this.field('text')

          searchDocuments.forEach(function (doc) {
            if (doc.id == "/404") {
              // don't index the content of the "404 not found" page
            } else {
              this.add(doc)
            }
          }, this)
        });

        // Function to execute the search
        var runSearch = function() {
          // Clear the previous results
          const resultsEl = document.getElementById("search-results");
          resultsEl.innerHTML = "";

          // Run the search
          const searchTerms = document.getElementById("search-terms").value;
          const results = lunrIndex.search(searchTerms);

          if (results.length == 0) {
            var noResults = document.createElement("p");
            noResults.textContent = "No results found";
            resultsEl.appendChild(noResults);
            return;
          }

          // Process the results
          results.forEach(function(result) {
            // This does not work because of word stemming (e.g. ruby => rubi)
            // var matchTerms = Object.keys(result.matchData.metadata).join(" ");
            var matchDoc = searchDocuments.find(x => x.id === result.ref)
            var linkEl = document.createElement("a");
            linkEl.href = matchDoc.id + "?hl=" + searchTerms;
            linkEl.text = matchDoc["name"];

            var resultEl = document.createElement("p");
            resultEl.appendChild(linkEl);

            resultsEl.appendChild(resultEl);
          });
        }

        // Make the search section visible
        document.getElementById("search-section").classList.remove("invisible");

        // Wire the click even in the search button
        document.getElementById("search-button").addEventListener("click", (event) => {
          runSearch();
        });

        // Wire the enter key on the search textbox
        // Source https://stackoverflow.com/a/46063448/446681
        document.getElementById("search-terms").addEventListener("keyup", (event) => {
          if (event.key === "Enter") {
            runSearch();
          }
        });

        // Give the focus to the search box
        document.getElementById("search-terms").focus();
      }
    </script>
  </body>
</html>
