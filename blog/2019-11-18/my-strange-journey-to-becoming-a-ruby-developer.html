<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="Five years ago (in 2014), after being a C# developer for many years I took my first job as a Ruby developer. Transitioning from one technology stack to another is not uncommon among software developers, most of us have jumped from one tech to another more than once in our lifetime (e.g. from DOS to Windows, from Desktop to web, from single user to client-server), but each transition is different, each one brings different challenges and rewards. In this post I want to reflect on how going from C# (on Windows) to Ruby (on Mac/Linux) worked out for me. Before taking a job as a Ruby developer I worked as a C# / .NET developer for 10+ years. My first .NET applications were Windows Desktop applications built with VB.NET and later on I moved on to build web applications with C#. When I came to Ruby, although I had little experience with Mac or Linux, I was very comfortable with foundational concepts like system design, object oriented programming, relational databases, web development, and such. A few years before I took my first job as a Ruby developer I bought a Mac to play with Ruby in my spare time. I spent many nights (hello Rails for Zombies) getting acquainted with the different tools and workflows that Ruby developers in the Mac and Linux ecosystem use. Initially, the switch from Graphical User Interfaces in Windows to working on the terminal in Mac/Linux was the biggest shock to me. But eventually I embraced it. I blogged about my initial non-professional experiences with Ruby on the Mac/Linux [in 2011](https://hectorcorrea.com/blog/ruby-development-on-the-mac-os-x/15) and [in 2012](https://hectorcorrea.com/blog/web-development-on-the-mac-os-x-part-ii/5).">
    <meta name="author" content="hector@hectorcorrea.com">

    <title>My (strange) journey to becoming a Ruby developer</title>

    <link rel="shortcut icon" href="/public/favicon.ico" />
    <link rel="apple-touch-icon" href="/public/favicon.png"/>

    <!-- Styles from https://newcss.net/ -->
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.css">

    <link rel="me" href="https://mastodon.social/@hectorjcorrea" />
    <base href="https://hectorcorrea.com" />

    <!-- Lunr.js for searching, Mark.js for highlighting search results -->
    <script src="/public/lunr.min.js"></script>
    <script src="/public/mark.min.js"></script>

    <style>
      img {
        padding: 5px;
        box-shadow: 3px 3px 8px #222;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      footer {
        background: var(--nc-bg-2);
        border-bottom: 1px solid var(--nc-bg-3);
        padding: 2rem 1.5rem;

        margin: -2rem calc(0px - (50vw - 50%)) 2rem;

        padding-left: calc(50vw - 50%);
        padding-right: calc(50vw - 50%);

        margin-top: -0px;
        margin-bottom: 0px;
        padding-top: 6px;
        padding-bottom: 6px;
        color: gray;
        font-size: x-small;
      }

      .header-link {
        /* Main body text, see new.css */
        color: var(--nc-tx-2);
        text-decoration: none;
      }

      .nav-link-selected {
        font-weight: bold;
      }

      .search-options {
        float: right;
      }

      .highlight-icon-on > a {
        background: var(--nc-ac-1);
      }

      .highlight-icon-off > a {
        background: var(--nc-bg-2);
      }

      .invisible {
        display: none;
      }

      .socialLogo {
        padding: 0px;
        box-shadow: none;
        margin-right: 0px;
        margin-bottom: 0px;
        width: 16px;
      }

      @media only screen and (max-width: 600px) {
        .about-image {
          float: none;
        }
      }

      @media only screen and (min-width: 600px) {
        .about-image {
          float: right;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1><a class="header-link" href="/">Hector Correa</a></h1>
      <nav>
        <a id="about-menu" href="/about">About</a>
        | <a id="presentations-menu" href="/presentations">Presentations</a>
        | <a id="blog-menu" href="/blog">Blog</a>
        <span class="search-options">
          <span>
            <a href="/search" title="Search">
              <!--Magnifying glass source: https://icons.getbootstrap.com/icons/search/ -->
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
                <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
              </svg></a>
          </span>
          <span id="highlight-menu" class="invisible">
            <a href="#" title="Toggle highlight">
              <!-- Highlighter source: https://icons.getbootstrap.com/icons/highlighter/ -->
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-highlighter" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M11.096.644a2 2 0 0 1 2.791.036l1.433 1.433a2 2 0 0 1 .035 2.791l-.413.435-8.07 8.995a.5.5 0 0 1-.372.166h-3a.5.5 0 0 1-.234-.058l-.412.412A.5.5 0 0 1 2.5 15h-2a.5.5 0 0 1-.354-.854l1.412-1.412A.5.5 0 0 1 1.5 12.5v-3a.5.5 0 0 1 .166-.372l8.995-8.07zm-.115 1.47L2.727 9.52l3.753 3.753 7.406-8.254zm3.585 2.17.064-.068a1 1 0 0 0-.017-1.396L13.18 1.387a1 1 0 0 0-1.396-.018l-.068.065zM5.293 13.5 2.5 10.707v1.586L3.707 13.5z"/>
              </svg>
            </a>
          </span>
        </span>
      </nav>
    </header>

    <div id="page-content">
      <h1>My (strange) journey to becoming a Ruby developer</h1>
<p>Five years ago (in 2014), after being a C# developer for many years I took my first job as a Ruby developer. Transitioning from one technology stack to another is not uncommon among software developers, most of us have jumped from one tech to another more than once in our lifetime (e.g. from DOS to Windows, from Desktop to web, from single user to client-server), but each transition is different, each one brings different challenges and rewards. In this post I want to reflect on how going from C# (on Windows) to Ruby (on Mac/Linux) worked out for me.</p>


<h2>Before Ruby</h2>
<p>Before taking a job as a Ruby developer I worked as a C# / .NET developer for 10+ years. My first .NET applications were Windows Desktop applications built with VB.NET and later on I moved on to build web applications with C#. When I came to Ruby, although I had little experience with Mac or Linux, I was very comfortable with foundational concepts like system design, object oriented programming, relational databases, web development, and such.</p>

<p>A few years before I took my first job as a Ruby developer I bought a Mac to play with Ruby in my spare time. I spent many nights (hello Rails for Zombies) getting acquainted with the different tools and workflows that Ruby developers in the Mac and Linux ecosystem use. Initially, the switch from Graphical User Interfaces in Windows to working on the terminal in Mac/Linux was the biggest shock to me. But eventually I embraced it. I blogged about my initial non-professional experiences with Ruby on the Mac/Linux <a href="https://hectorcorrea.com/blog/ruby-development-on-the-mac-os-x/15">in 2011</a> and <a href="https://hectorcorrea.com/blog/web-development-on-the-mac-os-x-part-ii/5">in 2012</a>.</p>


<h2>Why did I jump</h2>
<p>I didn't "rage quit" C# or anything like that. I enjoyed working in C# while I did it and I still think it's a great programming language. Yet, after noticing that the programming world outside of Windows was <i>so different and unknown to me</i> I wondered what was I missing by staying as a C# developer on Windows, particularly since there are more non-Windows developers that Windows developers. The idea of fully understanding this "other" way of building systems appealed to me.</p>


<h2>The non-technical part of my journey</h2>
<p>I took my first job as a Ruby developer with a wonderful team at Penn State in 2014. In this job I worked on a Ruby on Rails application built on top of the Hydra (now Samvera) framework. This was a challenging application because it was not a typical Ruby on Rails application talking to a relational database and being developed by a small collocated team. Instead the application stored its information in a <a href="https://duraspace.org/fedora/">repository platform with native linked data support</a> and <a href="http://lucene.apache.org/solr/">Solr</a>, it was developed using a large number of open source components that were in early development stages, and required collaboration and coordination with many developers outside of Penn State.</p>

<p>For me the challenging part of this project was not the Ruby part of the job, but rather the highly distributed nature of the team (in fact at one point I was one of the remote developers) and working with gems that were in early stages of development. I learned a lot and enjoyed the experience quite a bit. Since my job entailed working with people from a variety of institutions I had the opportunity to interact with a large number of Ruby developers and many of them were veterans in Ruby and Ruby on Rails which helped me better understand the Rails ecosystem.</p>

<p>Also, other than personal projects, this was the first time that I worked on an <a href="https://github.com/psu-stewardship/scholarsphere">open source application</a>. There is something beautiful about working in an environment in which your code is open for the world to see and allow other institutions to view it, use it, criticize it, or enhance it. This is something that would have been much harder for me to experience in the C# Windows world.</p>

<p>After a couple of years at Penn State, in 2016, I took a job at Brown University. At the Brown University Library I have been involved in Ruby on Rails projects that are also not exactly typical Rails applications in the sense that they interact with non-relational databases. A lot of the work that I have done at Brown involves <a href="https://github.com/Brown-University-Library/bul-search">working with Solr</a> and interacting with <a href="https://github.com/Brown-University-Library/vivo-on-rails">other systems via APIs</a>. This team has a very different structure than the one at Penn State. At the Brown University Library I am <i>the</i> Ruby developer (scary, right?), although there are many senior developers on the team that can write Ruby code, they are for the most part Python or PHP developers. Also this development team is collocated, smaller, and with close access to domain experts (librarians) that makes understanding requirements and iterating in the development process much simpler.</p>

<p>I believe a big part of my journey as a Ruby developer has been the fact that I went from working in the corporate world to the world of higher education. When I started learning Ruby I never thought I would end up working at large higher ed institutions, if anything I thought I would end up in a small organization or a startup.</p>


<h2>The programming journey</h2>
<p>Given that I have been a developer for many years learning Ruby was not too hard for me. The part of the language that took the longest to get used to was the dynamic typed nature of Ruby (C# is statically typed). There are some incredibly benefits of dynamic typing, and I love it, but there are tradeoffs too. Recently I have also been working with Go, which like C# supports static typing, and I love the safety net that it gives me as a developer, yet I cringe at how many times I have to declare something in Go before I can run even a small program. I cannot have it both ways I guess.</p>

<p>One thing that I love about Ruby is how easy is to prototype ideas. I am amazed how powerful the Ruby language is to create proof of concepts. The kind of work that I do requires a lot of exploratory steps and Ruby is perfect for this kind of work. The Ruby language comes built-in with tooling to connect to an HTTP endpoint, read/write files, parse JSON, manipulate arrays, create classes (or use plain hashes) without a lot of ceremony or verbosity. And of course Ruby is also very good to take the stuff from proof of concept to production, but the part that amazes me is the former.</p>

<p>Here is an example of a full Ruby program to connect to the Brown University Library catalog, search for books about "Ruby programming", and display the results (<i>note: this program no longer works because Brown has changed their library catalog, but the code is still a good example of the built-in functionality that comes with Ruby</i>). This little program shows how easy is to connect to an HTTP endpoint, convert the JSON response to Ruby hashes, sort them, iterate over them, and print them to the console:</p>

<pre>
require "net/http"
require "json"

# Make HTTP request
url = "https://search.library.brown.edu/catalog.json?q=ruby+programming&search_field=all_fields"
uri = URI(url)
response = Net::HTTP.get(uri)
json = JSON.parse(response)

# Create a simple array of hashes with the data
books = json["response"]["docs"].map do |doc|
    {
        title: doc["title_display"],
        author: doc["author_display"] || "unknown",
        year: doc["pub_date"].first.to_i
    }
end

# Sort descending by year
books = books.sort_by {|b| -b[:year] }

# Output to the console
books.each do |book|
    puts "#{book[:year]} - #{book[:title]} by #{book[:author]}"
end
</pre>

<p>Ruby on Rails on the other hand took me a while to grok. I am familiar with web technologies and I appreciate a lot of what Rails does for you but I also dislike some of the "magic" that is so prevalent in Rails applications. There are plenty of things in Rails that I love, like the fact that most applications follow a similar structure (models, views, and controllers), database migrations, the asset pipeline, routing of requests, ActiveController, ActiveRecord, and so on.</p>

<p>Although my last .NET projects used ASP.NET MVC I did a fair amount of Web Forms in ASP.NET as well (Viewstate anyone?) and I appreciate the simplicity of the request processing in Rails and how much closer it's to the way HTTP works than Web Forms.</p>

<p>After using Rails for 5 years I am finally comfortable turning off some of the default features, being more verbose in certain areas to expose the "magic", and do a more bare-bones web development within Rails. For example I try to use plain HTML tags in web pages (as opposed to Rails Helpers) since I prefer standard HTML than Rails specific syntax. I mean, unlike <a href="https://www.rubyguides.com/2019/05/rails-link_to-method/">RubyGuides</a> I would rather see</p>

<pre>
&lt;a href="/ruby-book"&gt;HTML rocks&lt;/a&gt;
</pre>

<p>than</p>

<pre>
&lt;%= link_to "HTML Rocks", "/ruby-book" %&gt;
</pre>

<p>but I suspect I am in the minority when it comes to this. I also prefer JavaScript to CoffeeScript (even thought at one point <a href="https://hectorcorrea.com/blog/a-decaf-introduction-to-coffeescript/1">I also thought CoffeeScript was a good idea</a>).</p>

<p>Likewise I use plain HTML + JavaScript as much as possible rather than the monstrosity that Rails does with the <a href="https://signalvnoise.com/posts/3697-server-generated-javascript-responses">Server Generated Javascript Responses</a> or <a href="https://guides.rubyonrails.org/working_with_javascript_in_rails.html#turbolinks">Turbolinks</a>, but maybe that's because I am comfortable with JavaScript and jQuery.</p>

<p>Perhaps one day I will write a book titled "Ruby on Rails the Good Parts" - just kidding.</p>

<h3>Dependencies and more dependencies</h3>
<p>I have mixed feelings about the way Rails applications are built using a very large number of external gems. The dependency nightmare that it introduces still baffles me, particularly when developers adopt a gem just to save a few lines of code. Keep in mind that I came from C# where the number of dependencies tends to be small compared to what we see in Rails applications. But as I become more familiar with Rails I am starting to notice that although there are many people that love to adopt gems (even at the expense of maintenance) there are also those that are cautious about it and give more though before adopting a dependency. The problem is that as a newcomer to the language is hard to see these patterns and know who and what to follow. But I am becoming better at this.</p>

<p>Part of the problem with dependencies is that Ruby is an interpreted language and does not produce binaries that you can just copy to a server and be done. Instead you have to download the code and resolve the dependencies on the server. This problem is augmented by the fact that we use different operating systems for development (Mac) from what we deploy in production (Linux). This works well most of the times but when it doesn't it can be hard to figure out and timing can be bad since I personally don't like surprises during deployment.</p>

<p>An example of an issue I ran into with dependencies was when a program required a version of a gem that had been removed from the RubyGem registry (e.g. <a href="https://rubygems.org/gems/logger/versions">logger 1.2.8 was yanked</a>). This was particularly tricky because I did not find out about it until I tried to deploy to production. My local machine had cached the version that had been yanked but the production server had not so it bombed when trying to resolve dependencies in the production server -- talk about bad timing. The problem is compounded by the fact that these dependencies can be very deep and you might not even know that your program depends on something until it causes problems.</p>

<p>Another issue with dependencies is the reliance on gems that require C extensions which is quite common (e.g. <code>nokogiri</code> and <code>mysql2</code>). This is a problem mostly because there are different default versions of the C compiler on Mac than on Linux and I have ran into issues where a particular gem that worked on my Mac did not compile on Linux because the gem <a href="https://github.com/sass/sassc-ruby/issues/37#issuecomment-248959463">required a new version of the GCC compiler</a> that was not installed on the Linux server. Having to hunt down specific versions of GCC compilers and installing them on a Linux server is really not what I want to learn when I am ready to deploy my Ruby application. Again this is also an artifact of developing on one operating system and deploying to another, but such is life in the Ruby world.</p>


<h3>Tooling</h3>
<p>One of the things that surprised me the most about developing and deploying Ruby applications was the large number of tools and configurations available. Seeing that people where using a variety of text editors, relational databases (MySQL, Postgres), web servers (Apache, Nginx), application servers (Passenger, Thin, Puma), and so on, was puzzling and complex to me at the beginning. Not to mention the tools for provisioning, deployment, and monitoring applications. Keep in mind I was coming from Window's web development where most applications where written in Visual Studio, used SQL Server as the database, IIS as the webserver, and that was it. Although there were variations in the Windows setup as well, they pale in comparison to the variety that I have experienced in the Ruby/Linux environment.</p>

<p>After 5 years working on Ruby/Linux environment I find this variety of tools quite normal and productive. I have personally tried many text editors, databases (relational and NoSQL), web servers, operating systems (OS X and many flavors of Linux), and whatnot.</p>

<p>I am now more comfortable with using more than one programming language too. I used to write all my tools and projects with C#. Now it's not uncommon for me to have projects in Ruby, Go, or even shell scripts to do a variety of things, and I am perfectly comfortable with this. This might just be a matter of professional growth as a developer (use the right tool for the job kind of thing) but I suspect it was largely influenced by the way the Linux world operates.</p>


<h2>In closing</h2>
<p>My journey from a C# developer to a Ruby developer has been very pleasant. I've learned a lot of new technologies and ways of doing things. In my case the biggest learning curve was not Ruby per-se but rather learning the Linux way of doing things. The other big learning curve was going from corporate to higher ed (academic libraries in particular) and that would probably be the subject of another post.</p>

<p>But my journey hasn't ended. I have a whole lot more to learn about Ruby and Mac/Linux before I am as proficient on it as I was on C# and Windows. And there are also a lot of other technologies that I am exploring or would like to explore. As I indicated before I am also using Go for some projects (like <a href="https://github.com/hectorcorrea/solrdora">solrdora</a> and <a href="https://github.com/hectorcorrea/marcli">marcli</a>) and recently I decided to learn Python since that's the language that most of the developers in my team use and it's pervasive in library-land. I am not planning on becoming a Python developer but I would like to become competent on it. To be fair, I wasn't planning on becoming a Ruby developer either when I started learning Ruby...so time will tell.</p>



    </div>

    <div id="search-section" class="invisible">
      <div id="search-params" class="">
        <input id="search-terms" size="50" />
        <button id="search-button">Go</button>
      </div>
      <div id="search-results">
      </div>
    </div>

    <footer>
      <a href="/tooling">Tooling</a> |
      License <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
    </footer>

    <script type="text/javascript">
      // Redirect legacy blog URLs
      if (window.location.hash.startsWith("#/blog")) {
        window.location = window.location.toString().replace("#/blog/","blog/");
      }

      // Hande this redirect via JavaScript because GitHub pages does not let me
      // handle this via an HTML redirect due to the ".aspx" extension
      if (window.location.pathname === "/blog/The-Mythical-Man-Month.aspx") {
        window.location = "https://hectorcorrea.com/blog/2007-06-28/the-mythical-man-month";
      }

      // Mark as selected the current menu option
      var selectMenu = function() {
        var activeOption = null;
        var url = window.location.pathname;
        if (url.startsWith("/blog/")) {
          activeOption = document.getElementById("blog-menu");
        } else if(url == "/about") {
          activeOption = document.getElementById("about-menu");
        } else if(url == "/presentations") {
          activeOption = document.getElementById("presentations-menu");
        }

        if (activeOption != null) {
          activeOption.classList.add("nav-link-selected");
        }
      }

      // Show the highlight menu if there is a hl query string parameter.
      // Notice that we don't automatically highlight search terms because that's annoying on the display
      // when there are too many hits.
      var showHighlightMenu = function() {
        const queryString = window.location.search
        const urlParams = new URLSearchParams(queryString);
        if (urlParams.has("hl")) {
          var hlMenu = document.getElementById("highlight-menu");
          hlMenu.classList.remove("invisible");
        }
      }

      // Highlight search terms indicated in the URL via the
      // hl query string parameter
      var highlightSearchTerms = function() {
        const queryString = window.location.search
        const urlParams = new URLSearchParams(queryString);
        if (urlParams.has("hl")) {
          var context = document.querySelector("#page-content");
          var instance = new Mark(context);
          instance.mark(urlParams.get("hl"));
          var hlMenu = document.getElementById("highlight-menu");
          hlMenu.classList.remove("invisible");
          hlMenu.classList.add("highlight-icon-on");
          hlMenu.classList.remove("highlight-icon-off");
        }
      }

      // Unhighlight the search terms
      var unhighlightSearchTerms = function() {
        var context = document.querySelector("#page-content");
        var instance = new Mark(context);
        instance.unmark();
        var hlMenu = document.getElementById("highlight-menu");
        hlMenu.classList.remove("highlight-icon-on");
        hlMenu.classList.add("highlight-icon-off");
      }

      // Wire the button to toggle the highlight
      document.getElementById("highlight-menu").addEventListener("click", (event) => {
        var hlMenu = document.getElementById("highlight-menu");
        if (hlMenu.classList.contains("highlight-icon-on")) {
          unhighlightSearchTerms();
        } else {
          highlightSearchTerms();
        }
        event.preventDefault();
      });

      // Open external links in a new tab
      var externalLinksNewTab = function() {
        var i;
        var links = document.getElementsByTagName("A");
        for(i = 0; i < links.length; i++) {
          var externalLink = !links[i].href.startsWith(window.location.origin);
          if (externalLink) {
            // Open on a new tab
            links[i].target = "_blank"
          }
        }
      }

      selectMenu();
      showHighlightMenu();
      externalLinksNewTab();
    </script>

    <script>
      if (window.location.pathname.startsWith("/search")) {
        // Only load the search index when we are on the search page
        // since it's kind of heavy, ~200KB.
        // Source https://stackoverflow.com/a/52478867/446681
        //
        // IMPORTANT: The call to document.write() will insert the
        // dynamic <script src=/searchIndex.js> block immediately
        // after this <script> block and therefore the code to
        // reference it MUST be on a separate <script> block.
        console.log("Loaded search index");
        document.write('<script src="/searchIndex.js"><\/script>');
      }
    </script>

    <script>
      // This <script> block has access to the searchDocuments
      // variable defined in searchIndex.js (see above)
      if (window.location.pathname.startsWith("/search")) {
        // Define the Lunr index
        var lunrIndex = lunr(function () {
          this.ref('id')
          this.field('name')
          this.field('text')

          searchDocuments.forEach(function (doc) {
            if (doc.id == "/404") {
              // don't index the content of the "404 not found" page
            } else {
              this.add(doc)
            }
          }, this)
        });

        // Function to execute the search
        var runSearch = function() {
          // Clear the previous results
          const resultsEl = document.getElementById("search-results");
          resultsEl.innerHTML = "";

          // Run the search
          const searchTerms = document.getElementById("search-terms").value;
          const results = lunrIndex.search(searchTerms);

          if (results.length == 0) {
            var noResults = document.createElement("p");
            noResults.textContent = "No results found";
            resultsEl.appendChild(noResults);
            return;
          }

          // Process the results
          results.forEach(function(result) {
            // This does not work because of word stemming (e.g. ruby => rubi)
            // var matchTerms = Object.keys(result.matchData.metadata).join(" ");
            var matchDoc = searchDocuments.find(x => x.id === result.ref)
            var linkEl = document.createElement("a");
            linkEl.href = matchDoc.id + "?hl=" + searchTerms;
            linkEl.text = matchDoc["name"];

            var resultEl = document.createElement("p");
            resultEl.appendChild(linkEl);

            resultsEl.appendChild(resultEl);
          });
        }

        // Make the search section visible
        document.getElementById("search-section").classList.remove("invisible");

        // Wire the click even in the search button
        document.getElementById("search-button").addEventListener("click", (event) => {
          runSearch();
        });

        // Wire the enter key on the search textbox
        // Source https://stackoverflow.com/a/46063448/446681
        document.getElementById("search-terms").addEventListener("keyup", (event) => {
          if (event.key === "Enter") {
            runSearch();
          }
        });

        // Give the focus to the search box
        document.getElementById("search-terms").focus();
      }
    </script>
  </body>
</html>
