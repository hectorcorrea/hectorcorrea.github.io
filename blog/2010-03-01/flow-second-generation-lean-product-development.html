<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" content="HectorCorrea.com">
    <meta name="author" content="hector@hectorcorrea.com">

    <title>HectorCorrea.com</title>

    <link rel="shortcut icon" href="/public/favicon.ico" />
    <link rel="apple-touch-icon" href="/public/favicon.png"/>

    <!-- Styles from https://newcss.net/ -->
    <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.css">

    <link rel="me" href="https://mastodon.social/@hectorjcorrea" />
    <link rel="canonical" href="https://hectorcorrea.com" />

    <script src="https://unpkg.com/lunr/lunr.js"></script>

    <style>
      img {
        padding: 5px;
        box-shadow: 3px 3px 8px #222;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      footer {
        background: var(--nc-bg-2);
        border-bottom: 1px solid var(--nc-bg-3);
        padding: 2rem 1.5rem;

        margin: -2rem calc(0px - (50vw - 50%)) 2rem;

        padding-left: calc(50vw - 50%);
        padding-right: calc(50vw - 50%);

        margin-top: -0px;
        margin-bottom: 0px;
        padding-top: 6px;
        padding-bottom: 6px;
        color: gray;
        font-size: x-small;
      }

      .header-link {
        /* Main body text, see new.css */
        color: var(--nc-tx-2);
        text-decoration: none;
      }

      .nav-link-selected {
        font-weight: bold;
      }

      .search-menu {
        float: right;
      }

      .invisible {
        display: none;
      }

      .socialLogo {
        padding: 0px;
        box-shadow: none;
        margin-right: 0px;
        margin-bottom: 0px;
        width: 16px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1><a class="header-link" href="/">Hector Correa</a></h1>
      <nav>
        <a id="about-menu" href="/about">About</a>
        | <a id="presentations-menu" href="/presentations">Presentations</a>
        | <a id="blog-menu" href="/blog">Blog</a>
        <span class="search-menu">
          <a href="/search" title="Search">
            <!--Magnifying glass source: https://icons.getbootstrap.com/icons/search/ -->
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
              <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
            </svg>
          </a>
        </span>
      </nav>
    </header>

    <div class="container">
      <h1>Flow: Second Generation Lean Product Development</h1>
<p><img alt="The Principles of Product Development Flow" width="120" height="178" align="left" src="https://hectorcorrea.com/images/flowbook.jpg" />The last few weeks I've been reading the book <a href="http://www.amazon.com/Principles-Product-Development-Flow-Generation/dp/1935401009">The Principles of Product Development Flow</a> by Donald Reinertsen<sup>[1]</sup> in which he describes what he calls the second generation of Lead Product Development.</p>

<p>I've been reading the book from the perspective of software development products and this review will highlight examples on that area. However Reinertsen's book is about product development in general (e.g. the development of a new drug or a new cell phone) and not software in particular.</p>

<p>Reinertsen describes a paradigm for product development that although it could be called Lean Product Development he chooses to call <b>Flow-Based Product Development</b> (Flow) to highlight the differences that exist between lean manufacturing and lean product development.</p>

<p>Unlike <i>lean manufacturing</i> that primarily deals with predictable and repeatable tasks, homogeneous delay costs, and homogeneous task duration, in <i>lean product development</i> these situations are not the norm. In product development the tasks (almost by definition) are not repeatable and hardly ever predictable, delay costs are not homogeneous, and tasks duration have very high variations.</p>

<p>In the case of software development it's not uncommon for teams to be dealing with problems that they have never solved before (e.g. writing a brand new system) or and with technologies that are new to the team. Likewise, the cost of delaying the implementation of a new feature versus the cost of fixing a specific bug can be widely different.</p>

<p>In chapter one Reinertsen starts by describing what he calls twelve critical problems with traditional product development orthodoxy including: Failure to Correctly Quantify Economics, Blindness to Queues, Worship of Efficiency, Hostility to Variability, Institutionalization of Large Batch Sizes, Underutilization of Cadence, Managing Timelines instead of Queues, Absence of Work-In-Progress Constraints, and Centralized Control.</p>

<p>In the remaining chapters of the book Reinertsen presents eight ideas/themes that he suggests to address these problems.</p>

<ul>
<li>Economics
<li>Queues
<li>Variability
<li>Batch Size
<li>WIP Constraints
<li>Cadence, Synchronization, and Flow Control
<li>Fast Feedback
<li>Decentralized Control
</ul>

<p>In software development some of these ideas are already popular thanks in large to the wide spread adoption of agile software development processes. For example Scrum recommendation of short sprints helps reduce <i>batch size</i>. Likewise, the daily collaboration between developers and QA during the sprint as well as frequent product demonstrations advocated by Scrum allow for <i>fast feedback</i> to take place.</p>

<p>However, some of the other ideas that Reinertsen presents on his book (like Economics, Queues, WIP Constraints) are not mainstream in software development yet. Some of the new development processes like Kanban<sup>[2][3]</sup> are making strides in these areas and this book helps to clarify why these changes are important in product development in general.</p>


<h2>On Economics</h2>

<p>On the topics of economics, Reinertsen starts with the premise that "we do product development to make money" (p.15) and yet most product development teams cannot correctly quantify economics on their products. In his view product developers currently focus on proxy variables to calculate economic impact rather than using the real economic objective which he calls &lt;strong&gt;life-cycle profits&lt;/strong&gt; (p.29)</p>

<p>For example, a typical proxy variable is cycle-time. Most developers typically try to optimize cycle-time and make it shorter. On the surface this sounds all good. However, few product developers can correctly calculate how much a delay on cycle-time will actually cost in terms of life-cycle profits.</p>

<p>An example of this in software development is when a team cannot objectively calculate the value (in terms of profit) of working on feature A or feature B. If the team does not know the impact to the bottom line, How can they make a decision that makes the more sense for the company? Without knowing the real value of two features, the team might decide to work on feature A because it's more appealing or because the developers needed for feature B are currently busy wrapping something else. However, if the team knew that feature B will bring four times more profit to the company if delivered first they might act different and rearrange the team to complete feature B before feature A.</p>

<p>Reinertsen points out that having a common unit of measure solves many problems as it allows the decisions on what makes more sense to take place on an even keel rather than using the unit of measurement that is popular at the moment. The common measure that he proposes is profits.</p>

<p>For example, given two choices to implement a feature a team might decide to rush it and release it to market rather than use a more comprehensive approach and wait a few months. Either one of these choices could be the correct one at different points in the life cycle of a product. However, the right choice depends on the economics of this decision at a given point in time. Will the company make more money rushing the feature and being first too market or will it make more money delaying its implementation and doing a more comprehensive implementation? What about the "technical debt" that the team will incur by rushing a feature? Does this cost outweigh the benefits of being first to market? All of these things should be considered and measured with the same unit.</p>

<p>Reinertsen indicates that on his research teams tend to <i>think</i> that they know the economics of their decisions. However,  when asking different people on the team to quantify (in economic terms) the value of the team decisions their responses vary on a 50 to 1 ratio. When the answers are in such wide range it's obvious that the team is not using a common unit of measurement.</p>

<p>Chapter two contains nineteen principles to help product developers make good decisions based on economics. Although Reinertsen does not provide the "silver-bullet" to make economic decisions the principles that he provides are a good place for product developers to start focusing including paying attention to Cost of Delay (p. 31), U-Curve Optimizations (p.35), Economics Trade-off  (p. 37), Marginal Cost and Marginal Value (p.45).</p>


<h2>On Queues and Batch Size</h2>

<p>One of the areas where lean manufacturing is very different from product development is in the management of queues. In lean manufacturing the problem with queues is well understood and has been optimized for many years. Entire manufacturing books have been written on how to manage bottlenecks on assembly lines to prevent inventory accumulation  (e.g. <a href="http://www.amazon.com/Goal-Process-Ongoing-Improvement/dp/0884270610">The Goal</a> by Eli Goldratt.) However, there is little literature in software development that addresses the effects of work in progress (which is the software equivalent to inventory.) An example of work in progress in software development are features developed but not yet in production either because they are under development or developed but still being tested.</p>

<p>One of the reasons work in progress (WIP) is so poorly managed in product development is because it's almost invisible. In manufacturing you can walk around a plant and see work in progress lying on the floor. Although work in progress does not sits around on the shop floor in software development work in progress can be easily identified by looking at queues: queues of items ready to be coded, items ready to be tested, items ready to be released, and so on.</p>

<p>You might be wondering, so what? Why should I care about queues in software development? Although there is no cost associated with <i>storing</i> work in progress in software development Reinertsen indicates that work in progress cause several unwanted side effects in product development including: <b>Longer Cycle Time, Increased Risk, More Variability, More Overhead, Lower Quality, and Less Motivation</b>.</p>

<p>An example of this in software development is a queue of features coded but not tested. The larger the queue of features coded but not tested the larger the test cycle that the product will need to go before the features can be released. A large number of features to be tested and then released also translate in higher risk on the new version of the system.</p>

<p>One of the principles of queue theory is called Little's Formula. In layman terms Little's Formula says "average queue size determines average cycle time" (p. 112.) This means that you can reduce cycle time by reducing batch size. This is important as it means that before we go looking for complex solutions to reduce long cycle times (like adding more staff or looking for bottlenecks) we can start by reducing the batch size. Software teams that are already using Agile methods like Scrum have experienced this with the use of short Sprints (e.g. 2-week long cycles) rather than the old-fashion multi-month development cycles.</p>

<p>On his book Agile Management for Software Engineering<sup>[4]</sup>, David Anderson gives a comprehensive explanation of how inventory and lead time apply to software and it's another good reference to learn more on this subject.</p>


<h2>On WIP Constraints</h2>

<p>After making you aware of Queues and the importance of Batch Size, Reinertsen moves to Work In Progress Constraints (or WIP Constraints) and why they are important in product development. Reinertsen indicates that while limiting batch size helps by nature to reduce the amount of work in progress, it does not address the fundamental problem of random variations in flow common to product development (p. 143) As Reinertsen indicates at the beginning of his book, product development is subject to many variations not common in lean manufacturing. In the Chapter 6 Reinertsen describes ideas and principles applied in telecommunication networks to deal with high variability and how they can be applied to product development. Instead of using a Theory of Constraints as a manufacturing book probably would, Reinertsen describes Kanban systems instead.</p>

<p>There is an entire movement in the software development industry to raise awareness of the problems that work in progress (WIP) causes to software processes. You can take a look at their work at <a href="http://www.limitedwipsociety.org/">http://www.limitedwipsociety.org/</a> and also a new book in the works on Kanban for Technology Organizations<sup>[2]</sup> by David Anderson.</p>


<h2>In Summary</h2>

<p>All in all I found Donald Reinertsen book very interesting and easy to read. Although the book is not specific to software development most of the concepts described on it apply to software development and would allow you to understand why the recommendations of agile, lean, or pull methods work and are important.</p>


<h3>References</h3>

<ul>
<li>[1] <i>Principles of Product Development Flow, Second Generation Lean Product Development</i>; Donald Reinertsen; Celeritas Publishing; 2009.
<li>[2] <i>Kanban: Successful Change Management for Technology Organizations</i>; David Anderson; Unpublished manuscript as of November 2009.
<li>[3] See <a href="http://www.kanban101.com/">http://www.kanban101.com</a> for a quick introduction to Kanban
<li>[4] <i>Agile Management for Software Engineering, Applying Theory of Constraints for Business Results</i>; David Anderson; Prentice Hall; 2003.

    </div>

    <div id="search-section" class="invisible">
      <div id="search-params" class="">
        <input id="search-terms" size="50" />
        <button id="search-button">Go</button>
      </div>
      <div id="search-results">
      </div>
    </div>

    <footer>
      License <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
    </footer>

    <script type="text/javascript">
      // Redirect legacy blog URLs
      if (window.location.hash.startsWith("#/blog")) {
        window.location = window.location.toString().replace("#/blog/","blog/");
      }

      // Hande this redirect via JavaScript because GitHub pages does not let me
      // handle this via an HTML redirect due to the ".aspx" extension
      if (window.location.pathname === "/blog/The-Mythical-Man-Month.aspx") {
        window.location = "https://hectorcorrea.com/blog/2007-06-28/the-mythical-man-month";
      }

      // Highlight the current menu option
      var highlightMenu = function() {
        var activeOption = null;
        var url = window.location.pathname;
        if (url.startsWith("/blog/")) {
          activeOption = document.getElementById("blog-menu");
        } else if(url == "/about") {
          activeOption = document.getElementById("about-menu");
        } else if(url == "/presentations") {
          activeOption = document.getElementById("presentations-menu");
        }

        if (activeOption != null) {
          activeOption.classList.add("nav-link-selected");
        }
      }

      highlightMenu();
    </script>

    <script>
      if (window.location.pathname.startsWith("/search")) {
        // Only load the search index when we are on the search page
        // since it's kind of heavy, ~200KB.
        // Source https://stackoverflow.com/a/52478867/446681
        //
        // IMPORTANT: The call to document.write() will insert the
        // dynamic <script src=/searchIndex.js> block immediately
        // after this <script> block and therefore the code to
        // reference it MUST be on a separate <script> block.
        console.log("Loaded search index");
        document.write('<script src="/searchIndex.js"><\/script>');
      }
    </script>

    <script>
      // This <script> block has access to the searchDocuments
      // variable defined in searchIndex.js (see above)
      if (window.location.pathname.startsWith("/search")) {
        // Define the Lunr index
        var lunrIndex = lunr(function () {
          this.ref('id')
          this.field('name')
          this.field('text')

          searchDocuments.forEach(function (doc) {
            if (doc.id == "/404") {
              // don't index the content of the "404 not found" page
            } else {
              this.add(doc)
            }
          }, this)
        });

        // Function to execute the search
        var runSearch = function() {
          // Clear the previous results
          const resultsEl = document.getElementById("search-results");
          resultsEl.innerHTML = "";

          // Run the search
          const searchTerms = document.getElementById("search-terms").value;
          const results = lunrIndex.search(searchTerms);

          if (results.length == 0) {
            var noResults = document.createElement("p");
            noResults.textContent = "No results found";
            resultsEl.appendChild(noResults);
            return;
          }

          // Process the results
          results.forEach(function(result) {
            var matchDoc = searchDocuments.find(x => x.id === result.ref)
            var linkEl = document.createElement("a");
            linkEl.href = matchDoc.id;
            linkEl.text = matchDoc["name"];

            var resultEl = document.createElement("p");
            resultEl.appendChild(linkEl);

            resultsEl.appendChild(resultEl);
          });
        }

        // Make the search section visible
        document.getElementById("search-section").classList.remove("invisible");

        // Wire the click even in the search button
        document.getElementById("search-button").addEventListener("click", (event) => {
          runSearch();
        });

        // Wire the enter key on the search textbox
        // Source https://stackoverflow.com/a/46063448/446681
        document.getElementById("search-terms").addEventListener("keyup", (event) => {
          if (event.key === "Enter") {
            runSearch();
          }
        });

        // Give the focus to the search box
        document.getElementById("search-terms").focus();
      }
    </script>
  </body>
</html>
